---
title: "Sorting items into optimal gearsets by Item power while filtering by user set amount of Tier pieces and minimum required Fire Resistance"
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
  html_notebook:
    toc: true
    toc_float: true
---

I took crafting the Fire Resist piece very seriously. The issue is - with Tier and other stuff it quickly becomes complicated. And it was bothering me a lot - What's the real bis for Heat2? Heat3? How does it change if I don't want to grind Argent Crusader rep? How does it change if I dont want to farm Jujus? Is it better to run Timbermaw Shoulder and/or Kazzak pants if I need to fill once piece with Fine Flarecore gear. Is it more optimal to lose some stats on jewelry or misc stuff like cape? How do I balance 6P and necessary FireRes so I'm minmaxing my damage?

To address these very important questions I made a script in R (I'm in biology so I don't know any better) which you can feed your shortlist of potential bis pieces, set how much Fire Resist you need, and it will spit out top-10 best gear combinations

It filters out all combinations that don't have at least 6 Tier pieces, then keeps only gear combinations for which total fire resist >= your input value and then sorts it by item power (ShadowEP in my case - this is stat weight from sixtyupgrades), and keeps top 10).

The script is below, you can run it in RStudio or any other R environment. You need to have the following libraries installed: readxl, dplyr, tidyr, combinat, writexl. You also need to have an Excel file with your shortlist of items. The file should have columns: Slot, Item, ShadowEP, FireRes, Tier. Slot is the gear slot (Head, Neck, Shoulder, etc), Item is the item name, ShadowEP is the stat weight from sixtyupgrades, FireRes is the fire resistance value, Tier is whether it's a Tier piece or not. You can download the Excel file I used here.

## Loading the required libraries and setting up the functions

### Loading the required libraries

```{r, ECHO=FALSE}
library(readxl)
library(dplyr)
library(tidyr)
library(combinat)
library(writexl)
```

Loading the .xlsx file with input data about items, needs to contain information about *Slot* - Head, Neck, Shoulder etc; *Item* - item name, *ShadowEP* - statweight information of the item (can be taken from sixtyupgrades), *FireRes* - fire resistance value, *Tier* - whether or not it's a tier piece

```{r}
# Read the Excel file
df <- read_excel("mylist2.xlsx")

# Convert columns to appropriate data types
df <- df %>%
  mutate(
    Slot = as.factor(Slot),
    Item = as.character(Item),
    ShadowEP = as.numeric(ShadowEP),
    FireRes = as.numeric(FireRes),
    Tier = as.factor(Tier)
  )

df <- df[c(1:3,6,10)]  # Filter the necessary columns
```

### Function to pre-filter the data into all possible gearset combinations 
#### With the set number of Tier pieces 

Default number of Tier pieces is 2 or more, can be changed in 'min_tier_yes = 2' to other number 
Warning: if you input too much items, and tier_yes_count is also high it might take forever to calculate

```{r}
get_valid_combinations <- function(df, min_tier_yes_count = 2) {
  # Split data by Slot
  slots <- split(df, df$Slot)
  
  # Initialize a list to store valid combinations
  valid_combinations <- list()
  
  # Generate combinations
  combn_helper <- function(slot_lists, current_comb = data.frame(), depth = 1) {
    if (depth > length(slot_lists)) {
      # Check if current_comb has 2 or more items with Tier == 'Yes'
      if (sum(current_comb$Tier == 'Yes') >= min_tier_yes_count) {
        valid_combinations <<- append(valid_combinations, list(current_comb))
      }
      return()
    }
    
    # Iterate through items in the current slot
    for (i in 1:nrow(slot_lists[[depth]])) {
      combn_helper(slot_lists, rbind(current_comb, slot_lists[[depth]][i, ]), depth + 1)
    }
  }
  
  # Start the recursive combination generation
  combn_helper(slots)
  
  return(valid_combinations)
}

```

#### Without Tier constraint

Alternative approach for when you don't care about the Tier 

>get_valid_combinations <- function(df) {
  # Split data by Slot
  slots <- split(df, df$Slot)
  
>  # Initialize a list to store valid combinations
  valid_combinations <- list()
  
>  # Generate combinations
  combn_helper <- function(slot_lists, current_comb = data.frame(), depth = 1) {
    if (depth > length(slot_lists)) {
      # Add the current combination to the list of valid combinations
      valid_combinations <<- append(valid_combinations, list(current_comb))
      return()
    }
    
>  # Iterate through items in the current slot
    for (i in 1:nrow(slot_lists[[depth]])) {
      combn_helper(slot_lists, rbind(current_comb, slot_lists[[depth]][i, ]), depth + 1)
    }
  }
  
>  # Start the recursive combination generation
  combn_helper(slots)
  
>  return(valid_combinations)
>}


### Function to filter the combinations based on a set Fire Resistance value

Taking the gearsets from previous output and getting rid of anything but gearset for which total X =< Fire Resistance < X+15 where X is a user input value which we will set later

```{r}
# Function to filter combinations based on Fire Res values
filter_combinations_by_fire_res <- function(combinations, X) {
  filtered_combinations <- list()
  
  for (comb in combinations) {
    # Check the structure and summary of the combination
    #print(str(comb))
    #print(summary(comb$FireRes))
    
    # Ensure FireRes is numeric
    comb$FireRes <- as.numeric(comb$FireRes)
    
    # Calculate the sum of FireRes, ignoring NA values
    fire_res_sum <- sum(comb$FireRes, na.rm = TRUE)
    
    # Print the sum for debugging
    #print(paste("Fire Res Sum:", fire_res_sum))
    
    # Check if the sum falls within the specified range
    if (!is.na(fire_res_sum) && !is.null(fire_res_sum) && fire_res_sum >= X && fire_res_sum <= X + 15) {
      filtered_combinations <- append(filtered_combinations, list(comb))
    } else {
      #print(paste("Filtered out - Fire Res Sum:", fire_res_sum, "Not in range"))
    }
  }
  
  return(filtered_combinations)
}
```

### Function to sort combinations by item power

Taking the gearsets from previous output, sorting them by item power (ShadowEP) and keeping only ~top 10 gearsets

```{r}

# Function to get top combinations based on ShadowEP
get_top_combinations_by_shadow_ep <- function(combinations, top_n = 250) {
  # Calculate the sum of ShadowEP and FireRes for each combination
  combinations_with_totals <- lapply(combinations, function(comb) {
    total_shadow_ep <- sum(comb$ShadowEP)
    total_fire_res <- sum(comb$FireRes)
    comb$total_shadow_ep <- total_shadow_ep
    comb$total_fire_res <- total_fire_res
    return(comb)
  })
  
  # Convert list to data frame for sorting
  combinations_with_totals_df <- do.call(rbind, lapply(combinations_with_totals, function(comb) {
    data.frame(
      Slot = comb$Slot,
      Item = comb$Item,
      ShadowEP = comb$ShadowEP,
      FireRes = comb$FireRes,
      Tier = comb$Tier,
      total_shadow_ep = comb$total_shadow_ep,
      total_fire_res = comb$total_fire_res,
      stringsAsFactors = FALSE
    )
  }))
  
  # Ensure the total_shadow_ep column is numeric
  combinations_with_totals_df$total_shadow_ep <- as.numeric(combinations_with_totals_df$total_shadow_ep)
  
  # Sort combinations by total ShadowEP in descending order
  sorted_combinations_df <- combinations_with_totals_df[order(combinations_with_totals_df$total_shadow_ep, decreasing = TRUE), ]
  
  # Extract top N combinations
  top_combinations_df <- head(sorted_combinations_df, top_n)
  
  # Convert back to list of data frames
  top_combinations <- split(top_combinations_df, seq(nrow(top_combinations_df)))
  
  # Print the structure of top combinations for debugging
  #print(lapply(top_combinations, str))
  
  return(top_combinations)
}
```

### Function to write down Top-10 Gear Sets

```{r}
# Create a new data frame from top_combinations
create_summary_df <- function(top_combinations) {
  # Initialize an empty list to store data
  summary_list <- list()
  
  # Initialize the combination number
  comb_number <- 1
  
  # Loop through top_combinations and extract the required information
  for (i in seq_along(top_combinations)) {
    comb <- top_combinations[[i]]
    
    # Extract current combination's total ShadowEP and FireRes
    current_shadow_ep <- comb$total_shadow_ep
    current_fire_res <- comb$total_fire_res
    
    # For the first combination, we don't need to check the previous values
    if (i > 1) {
      prev_comb <- top_combinations[[i - 1]]
      prev_shadow_ep <- prev_comb$total_shadow_ep
      prev_fire_res <- prev_comb$total_fire_res
      
      # Check if both total ShadowEP and total FireRes are different from the previous combination
      if (current_shadow_ep != prev_shadow_ep || current_fire_res != prev_fire_res) {
        comb_number <- comb_number + 1
      }
    }
    
    # Stop if comb_number exceeds 11
    if (comb_number > 10) break
    
    # Create a data frame for each combination
    comb_df <- data.frame(
      CombinationNumber = comb_number,
      Slot = comb$Slot,
      Item = comb$Item,
      TotalShadowEP = comb$total_shadow_ep,
      TotalFireRes = comb$total_fire_res,
      stringsAsFactors = FALSE
    )
    
    # Append to the summary list
    summary_list[[i]] <- comb_df
  }
  
  # Combine all data frames in the summary list into a single data frame
  summary_df <- do.call(rbind, summary_list)
  
  return(summary_df)
}# Create a new data frame from top_combinations
create_summary_df <- function(top_combinations) {
  # Initialize an empty list to store data
  summary_list <- list()
  
  # Initialize the combination number
  comb_number <- 1
  
  # Loop through top_combinations and extract the required information
  for (i in seq_along(top_combinations)) {
    comb <- top_combinations[[i]]
    
    # Extract current combination's total ShadowEP and FireRes
    current_shadow_ep <- comb$total_shadow_ep
    current_fire_res <- comb$total_fire_res
    
    # For the first combination, we don't need to check the previous values
    if (i > 1) {
      prev_comb <- top_combinations[[i - 1]]
      prev_shadow_ep <- prev_comb$total_shadow_ep
      prev_fire_res <- prev_comb$total_fire_res
      
      # Check if both total ShadowEP and total FireRes are different from the previous combination
      if (current_shadow_ep != prev_shadow_ep || current_fire_res != prev_fire_res) {
        comb_number <- comb_number + 1
      }
    }
    
    # Stop if comb_number exceeds 11
    if (comb_number > 10) break
    
    # Create a data frame for each combination
    comb_df <- data.frame(
      CombinationNumber = comb_number,
      Slot = comb$Slot,
      Item = comb$Item,
      TotalShadowEP = comb$total_shadow_ep,
      TotalFireRes = comb$total_fire_res,
      stringsAsFactors = FALSE
    )
    
    # Append to the summary list
    summary_list[[i]] <- comb_df
  }
  
  # Combine all data frames in the summary list into a single data frame
  summary_df <- do.call(rbind, summary_list)
  
  return(summary_df)
}
```

## Inputing our values and getting the results
### Inputing the Fire Resistance value X
```{r}
#Reminder: You have 27 Fire Res from 4 Tierpiece gear, 60(75) from Enchants, and 27 from MotW. 
#H2: 96 (69 with MotW, 9 with three easy enchants)
#H3: 226 (199 with MotW, 139 with three easy enchants 
#H3: 226 (If you are using Juju and MR pot instead of MotW 161 - with three easy enchants 101 - with AD rep 86 - with 4P 59)

# User input for the numeric value X
# X <- as.numeric(readline(prompt = "Enter the numeric value for X: ")) - this is for user set, commenting it out to knit the document
X <- as.numeric(59)
```

### Applying the functions

#### Get valid combinations

```{r}
valid_combinations <- get_valid_combinations(df)
```

#### Filter valid combinations by Fire Res values
```{r}
filtered_combinations <- filter_combinations_by_fire_res(valid_combinations, X)
```

#### Get top combinations by ShadowEP
```{r, echo=FALSE}
top_combinations <- get_top_combinations_by_shadow_ep(filtered_combinations)
```

#### Write down the results in a new data frame
```{r}
summary_df <- create_summary_df(top_combinations)
print(summary_df[1:30,])
```

### Writing the summary to an Excel file
```{r}
# Write summary_df to an Excel file
write_xlsx(summary_df, "output.xlsx")
```